// This class is dedicated to the memory of my old ImageWriter I, the best printer in the history of mankind. :-)
// It weighed about half a ton and could not be rendered inoperable by anything short of a direct nuclear strike.

package main

import (
	"fmt"
	"image"
	"image/color"
	"image/png"
	"os"
	"time"
)

// Generates a PNG image of the current state of the arena.
type ImageWriter struct {
	Dir string
	Prefix string
	NextFileIndex int
	PixelsPerCell int
	CurrentImage *ArenaImage
}

func NewImageWriter(prefix string, pixelsPerCell int) ImageWriter {
	dir := fmt.Sprintf("/tmp/robot-arena-%d-%d", os.Getpid(), time.Now().UnixNano())
	if err := os.Mkdir(dir, 0755); err != nil {
		logger.Fatalf("Could not create temporary directory %s: %v", dir, err)
	}

	return ImageWriter{dir, prefix, 0, pixelsPerCell, nil}
}

// The names have to be lexicographically sorted so that they're assembled in the right order.
func (writer *ImageWriter) NextFileName() string {
	path := fmt.Sprintf("%s/%s_%011d.png", writer.Dir, writer.Prefix, writer.NextFileIndex)
	writer.NextFileIndex++
	return path
}

// Returns a glob path that matches all the images generated by this ImageWriter.
func (writer *ImageWriter) WildCard() string {
	return fmt.Sprintf("%s/%s_*.png", writer.Dir, writer.Prefix)
}

func (writer *ImageWriter) WriteImage(state *GameState, action *Action) {
	writer.StartImage(state.Arena)
	writer.DrawGameState(state, action)
	writer.FinishImage()
}

func (writer *ImageWriter) StartImage(arena *Arena) {
	writer.CurrentImage = NewArenaImage(writer.NextFileName(), arena.Width, arena.Height, writer.PixelsPerCell)

	// Draw the map
	for x := 0; x < writer.CurrentImage.Width; x++ {
		for y := 0; y < writer.CurrentImage.Height; y++ {
			cell := arena.Cells[x * writer.CurrentImage.Height + y]
			switch cell.Type {
			case WallCell:
				writer.CurrentImage.DrawCell(x, y, color.RGBA{0, 0, 0, 255}) // black
			case SpawnCell, OpenCell:
				writer.CurrentImage.DrawCell(x, y, color.RGBA{255, 255, 255, 255}) // white
			case GoalCell:
				writer.CurrentImage.DrawCell(x, y, color.RGBA{0, 255, 0, 255}) // green
			}
		}
	}
}

func (writer *ImageWriter) DrawGameState(state *GameState, action *Action) {
	// Draw the bots. Dead bots show up as a light color.
	for _, bot := range state.Bots {
		var c color.RGBA
		if bot.Team == TeamA {
			if bot.Alive {
				c = color.RGBA{255, 0, 0, 255} // red
			} else {
				c = color.RGBA{255, 100, 100, 255} // light red
			}
		} else {
			if bot.Alive {
				c = color.RGBA{0, 0, 255, 255} // blue
			} else {
				c = color.RGBA{100, 100, 255, 255} // light blue
			}
		}
		writer.CurrentImage.DrawCell(bot.Position.X, bot.Position.Y, c)
	}

	// Draw the semi-transparent lasers as half-width lines. (This is not terribly efficient. Lots of overdraw.)
	if action != nil && action.Type == ActionShoot {
		shooterX := state.CurrentBot.Position.X * writer.PixelsPerCell + writer.PixelsPerCell / 2
		shooterY := state.CurrentBot.Position.Y * writer.PixelsPerCell + writer.PixelsPerCell / 2
		targetX := action.Target.X * writer.PixelsPerCell + writer.PixelsPerCell / 2
		targetY := action.Target.Y * writer.PixelsPerCell + writer.PixelsPerCell / 2

		var laserColor color.RGBA
		if state.CurrentBot.Team == TeamA {
			laserColor = color.RGBA{255, 0, 0, 128} // red, 50% transparency
		} else {
			laserColor = color.RGBA{0, 0, 255, 128} // blue, 50% transparency
		}
		quarterWidth := writer.PixelsPerCell / 4

		BresenhamLine(shooterX, shooterY, targetX, targetY, func (x, y int) bool {
			rect := image.Rect(x - quarterWidth, y - quarterWidth, x + quarterWidth, y + quarterWidth)
			writer.CurrentImage.DrawRect(rect, laserColor)
			return true
		})
	}
}

func (writer *ImageWriter) FinishImage() {
	path := writer.CurrentImage.Filename
	f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		logger.Fatalf("Can't open file %s: %v", path, err)
	}

	err = png.Encode(f, writer.CurrentImage.Image)
	if err != nil {
		logger.Fatalf("Can't write image data to file %s: %v", path, err)
	}

	err = f.Close()
	if err != nil {
		logger.Fatalf("Can't close file %s: %v", path, err)
	}
	writer.CurrentImage = nil
}
